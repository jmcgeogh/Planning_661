#!/usr/bin/env python

import rospy
import math
import sys
import tf
import copy
import operator
from geometry_msgs.msg import Twist, Point
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion
from velocity_publisher import computation

# Initialize your ROS node
rospy.init_node("move_robot")
# Set up a publisher to the /cmd_vel topic
pub = rospy.Publisher("cmd_vel", Twist, queue_size=5)
# Declare a message of type Twist
velocity_msg = Twist()
# publish the velocity at 4 Hz (4 times per second)
rate = rospy.Rate(4)
# set up a tf listener to retrieve transform between the robot and the world
tf_listener = tf.TransformListener()
# parent frame for the listener
parent_frame = 'odom'
# child frame for the listener
child_frame = 'base_footprint'
# gains for the proportional controllers. These values can be tuned.
k_h_gain = 1
k_v_gain = 1

try:
    tf_listener.waitForTransform(parent_frame, child_frame, rospy.Time(), rospy.Duration(1.0))
except (tf.Exception, tf.ConnectivityException, tf.LookupException):
    rospy.loginfo("Cannot find transform between {p} and {c}".format(p=parent_frame, c=child_frame))
    rospy.signal_shutdown("tf Exception")

store_theta = [0]
store_x = [1]
store_y = [1]
def get_odom_data():
    """Get the current pose of the robot from the /odom topic

    Return
    ----------
    The position (x, y, z) and the yaw of the robot.

    """
    try:
        (trans, rot) = tf_listener.lookupTransform(parent_frame, child_frame, rospy.Time(0))
        # rotation is a list [r, p, y]
        rotation = euler_from_quaternion(rot)
    except (tf.Exception, tf.ConnectivityException, tf.LookupException):
        rospy.loginfo("TF Exception")
        return
    # return the position (x, y, z) and the yaw
    return Point(*trans), rotation[2]

def go_straight(dist):
    """Move the robot in a straight line until it has driven a certain distance.

    The linear velocity is modified for a Twist message and then published on /cmd_vel.

    """

    # get distance and linear velocity from command line
    distance_to_drive, linear_velocity = dist, 0.2
    global velocity_msg
    # update linear.x from the command line
    velocity_msg.linear.x = linear_velocity
    # get the current time (s)
    t_0 = rospy.Time.now().to_sec()
    # keep track of the distance
    distance_moved = 0.0

    # while the amount of distance has not been reached
    while distance_moved <= distance_to_drive:
        rospy.loginfo("TurtleBot is moving")
        pub.publish(velocity_msg)
        rate.sleep()
        # time in sec in the loop
        t_1 = rospy.Time.now().to_sec()
        distance_moved = (t_1 - t_0) * abs(linear_velocity)
        rospy.loginfo("distance moved: {0}".format(distance_moved))

    rospy.loginfo("Distance reached")
    # finally, stop the robot when the distance is moved
    velocity_msg.linear.x = 0.0
    pub.publish(velocity_msg)


def rotate(theta):
    """Make the robot rotate in place

    The angular velocity is modified before publishing the message on the topic /cmd_vel.
    """

    # angular_velocity = math.radians(angular_velocity)
    relative_angle_degree, angular_velocity = theta, .2
    velocity_msg.angular.z = angular_velocity

    t0 = rospy.Time.now().to_sec()
    while True:
        rospy.loginfo("TurtleBot is rotating")
        pub.publish(velocity_msg)
        rate.sleep()
        t1 = rospy.Time.now().to_sec()
        rospy.loginfo("t0: {t}".format(t=t0))
        rospy.loginfo("t1: {t}".format(t=t1))
        current_angle_degree = (t1 - t0) * angular_velocity

        rospy.loginfo("current angle: {a}".format(a=current_angle_degree))
        rospy.loginfo("angle to reach: {a}".format(a=relative_angle_degree))
        if abs(current_angle_degree) >= math.radians(abs(relative_angle_degree)):
            # rospy.loginfo("reached")
            break
    # finally, stop the robot when the distance is moved
    velocity_msg.angular.z = 0
    pub.publish(velocity_msg)

start_x = 1
start_y = 1
start_theta = 45
goal_x = 9
goal_y = 9
RPM1 = 15
RPM2 = 30
clearance = 0.2

clearance = int(clearance * 100)

def CoordToString(x, y):
    if x // 10 < 1:  # lists location as a string with 8 integers (x and y coords) (00000000 to 10001000)
        stringx = '000'
    elif x // 10 < 10:
        stringx = '00'
    elif x // 10 < 100:
        stringx = '0'
    else:
        stringx = ''
    if y // 10 < 1:
        stringy = '000'
    elif y // 10 < 10:
        stringy = '00'
    elif y // 10 < 100:
        stringy = '0'
    else:
        stringy = ''
    return stringx, stringy


obstacles = []

for i in range(0, clearance + 1):  # left boundary
    for j in range(0, 1001):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(0, 1001):  # bottom boundary
    for j in range(0, clearance + 1):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(1000 - clearance, 1001):  # right boundary
    for j in range(0, 1001):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(0, 1001):  # top boundary
    for j in range(1000 - clearance, 1001):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(100 - clearance, 300 + clearance):  # obstacle 1: circle
    for j in range(100 - clearance, 300 + clearance):
        if ((i - 200) ** 2 + (j - 200) ** 2 < (100 + clearance) ** 2):
            x = i
            y = j
            stringx, stringy = CoordToString(x, y)
            location = str(stringx + str(int(x)) + stringy + str(int(y)))
            obstacles.append(location)
        else:
            pass

for i in range(100 - clearance, 300 + clearance):  # obstacle 2: circle
    for j in range(700 - clearance, 900 + clearance):
        if ((i - 200) ** 2 + (j - 800) ** 2 < (100 + clearance) ** 2):
            x = i
            y = j
            stringx, stringy = CoordToString(x, y)
            location = str(stringx + str(int(x)) + stringy + str(int(y)))
            obstacles.append(location)
        else:
            pass

for i in range(25 - clearance, 176 + clearance):  # obstacle 3: sqaure
    for j in range(425 - clearance, 576 + clearance):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(375 - clearance, 626 + clearance):  # obstacle 4: rectangle
    for j in range(425 - clearance, 576 + clearance):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(725 - clearance, 876 + clearance):  # obstacle 5: rectangle
    for j in range(200 - clearance, 401 + clearance):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

startx, starty = CoordToString(int(start_x * 100), int(start_y * 100))
start_loc = str(startx + str(int(start_x * 100)) + starty + str(int(start_y * 100)))

goalx, goaly = CoordToString(int(goal_x * 100), int(goal_y * 100))
goal_loc = str(goalx + str(int(goal_x * 100)) + goaly + str(int(goal_y * 100)))

if start_loc in obstacles:  # checks that are the inputs are valid
    print("Starting coordinates are either in obstacle or too close to obstacle/boundary. Please try again.")
    sys.exit()

if goal_loc in obstacles:
    print("Goal coordinates are either in obstacle or too close to obstacle/boundary. Please try again.")
    sys.exit()

if start_x > 10 or start_x < 0 or start_y > 10 or start_y < 0:
    print("Starting coordinates are outside boundaries. Please try again.")
    sys.exit()

if goal_x > 10 or goal_x < 0 or goal_y > 10 or goal_y < 0:
    print("Goal coordinates are outside boundaries. Please try again.")
    sys.exit()

actions = [[RPM1, RPM1], [RPM1, 0], [0, RPM1], [RPM1, RPM2], [RPM2, RPM1], [RPM2, RPM2], [0, RPM2], [RPM2, 0]]
path = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

travelled = {}
travelled = {start_loc: [0, 'Q', start_theta, 0]}  # the dictionary of travelled points

def plot_curve(Xi, Yi, Thetai, UL, UR):
    t = 0
    r = 0.038
    L = 0.354
    dt = 0.1
    Xn = Xi
    Yn = Yi
    Thetan = 3.14 * Thetai / 180
    D = 0
    while t < 0.5:
        t = t + dt
        Xs = Xn
        Ys = Yn
        Xn += 0.5 * r * (UL + UR) * math.cos(Thetan) * dt
        Yn += 0.5 * r * (UL + UR) * math.sin(Thetan) * dt
        Thetan += (r / L) * (UR - UL) * dt
        D = math.sqrt(math.pow((0.5 * r * (UL + UR) * math.cos(Thetan) * dt), 2) + math.pow(
            (0.5 * r * (UL + UR) * math.sin(Thetan) * dt), 2))
    Thetan = 180 * (Thetan) / 3.14
    return Xn, Yn, Thetan, D

def checkGoal(x, y):  # function checks if the current node is within the accepted radius of the goal
    if (goal_x - 0.2 <= x <= goal_x + 0.2) and (goal_y - 0.2 <= y <= goal_y + 0.2):
        return True
    else:
        return False

current_x = copy.deepcopy(start_x)
current_y = copy.deepcopy(start_y)
current_cost = travelled[start_loc][0]
current_p = travelled[start_loc][1]
current_theta = travelled[start_loc][2]
current_ctc = travelled[start_loc][3]

done = 0
while checkGoal(current_x, current_y) == False:
#while done < 10:
    i = 0
    done += 1
    for action in actions:
        p = path[i]
        i += 1
        X1 = plot_curve(current_x, current_y, current_theta, action[0], action[1])
        x, y = CoordToString(int(round(X1[0], 2) * 100), int(round(X1[1], 2) * 100))
        loc = str(x + (str(int(round(X1[0], 2) * 100))) + y + (str(int(round(X1[1], 2) * 100))))
        if (loc not in obstacles) and (loc not in travelled) and X1[0] > 0 and X1[0] < 10 and X1[1] > 0 and X1[1] < 10:
            ctg = math.sqrt(((goal_x - X1[0]) ** 2) + ((goal_y - X1[1]) ** 2))
            ctc = current_ctc + X1[3]
            cost = ctc + ctg
            p = current_p + p
            update = {loc: [cost, p, X1[2], ctc]}
            travelled.update(update)

    del travelled[start_loc]
    travelled_copy = copy.deepcopy(travelled)
    travelled_copy = sorted(travelled_copy.items(), key=operator.itemgetter(1))

    #travelled = {k: v for k, v in sorted(travelled.items(), key=lambda item: item[1])}
    #print(travelled_copy)
    #start_loc = list(travelled.keys())[0]  # updates the next parent node to be the one with the lowest cost
    start_loc = travelled_copy[0][0]
    #print(start_loc)
    #print(start_loc[0:4])
    #print(int(start_loc[0:4]))
    #print(float(float(start_loc[0:4])/100))
    current_x = float(start_loc[0:4]) / 100
    current_y = float(start_loc[4:]) / 100
    #current_cost = list(travelled.values())[0][0]
    current_cost = travelled_copy[0][1][0]
    #current_p = list(travelled.values())[0][1]
    current_p = travelled_copy[0][1][1]
    #current_theta = list(travelled.values())[0][2]
    current_theta = travelled_copy[0][1][2]
    #current_ctc = list(travelled.values())[0][3]
    current_ctc = travelled_copy[0][1][3]
    #print(type(travelled))
    #print(type(travelled_copy))
    if current_theta != store_theta[-1]:
        rotate(current_theta)
    dist = math.sqrt((current_x - store_x[-1])**2 + (current_y - store_y[-1])**2)
    go_straight(dist)
    print(current_x, current_y)
    print(current_theta)
    store_theta.append(current_theta)

