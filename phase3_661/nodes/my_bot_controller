#!/usr/bin/env python

import rospy
import math
import sys
import tf
import copy
import operator
from geometry_msgs.msg import Twist, Point
from sensor_msgs.msg import LaserScan
from tf.transformations import euler_from_quaternion
from velocity_publisher import computation

# Initialize ROS node
rospy.init_node("move_robot")
# Set up a publisher to the /cmd_vel topic
pub = rospy.Publisher("cmd_vel", Twist, queue_size=5)
# Declare a message of type Twist
velocity_msg = Twist()
# publish the velocity
rate = rospy.Rate(4)
# set up a tf listener to retrieve transform between the robot and the world
tf_listener = tf.TransformListener()
# parent frame for the listener
parent_frame = 'odom'
# child frame for the listener
child_frame = 'base_footprint'

#####Robot Motion#####
# Ensure the transform between the robot and world can be read
try:
    tf_listener.waitForTransform(parent_frame, child_frame, rospy.Time(), rospy.Duration(1.0))
except (tf.Exception, tf.ConnectivityException, tf.LookupException):
    rospy.loginfo("Cannot find transform between {p} and {c}".format(p=parent_frame, c=child_frame))
    rospy.signal_shutdown("tf Exception")

# Get the current position and orientation from the /odom topic
def odom():
    try:
        (trans, rot) = tf_listener.lookupTransform(parent_frame, child_frame, rospy.Time(0))
        # rotation is a list [r, p, y]
        rotation = euler_from_quaternion(rot)
    except (tf.Exception, tf.ConnectivityException, tf.LookupException):
        rospy.loginfo("TF Exception")
        return
    # return the position and orientation
    return Point(*trans), rotation[2]

def move(goal_x, goal_y):
    # call the /odom topic to get current robot position
    (position, rotation) = odom()
    last_rotation = 0
    # Adjust the goal to match the gazebo world
    goal_x = goal_x - 5
    goal_y = goal_y - 5
    # compute the distance from the current position to the next goal point
    distance_to_goal = computation.compute_distance(position.x, position.y, goal_x, goal_y)

    while distance_to_goal > 0.05:
        # Continue to update the current position
        (position, rotation) = odom()
        x_start = position.x
        y_start = position.y
        # Get the angle of rotation from the current orientation to the goal position
        angle_to_goal = math.atan2(goal_y - y_start, goal_x - x_start)

        # restrict the domain of arctan(x) to (0, 2pi)
        if angle_to_goal < -math.pi/4 or angle_to_goal > math.pi/4:
            if 0 > goal_y > y_start:
                angle_to_goal = -2 * math.pi + angle_to_goal
            elif 0 <= goal_y < y_start:
                angle_to_goal = 2 * math.pi + angle_to_goal
        if last_rotation > math.pi - 0.1 and rotation <= 0:
            rotation = 2 * math.pi + rotation
        elif last_rotation < -math.pi + 0.1 and rotation > 0:
            rotation = -2 * math.pi + rotation

        # Rotate the robot
        velocity_msg.angular.z = angle_to_goal-rotation
        # Get the distance from the current position to the goal position
        distance_to_goal = computation.compute_distance(position.x, position.y, goal_x, goal_y)
        # Move the robot linearly only when it is facing the goal position
        if -.07 <= velocity_msg.angular.z <= .07:
            velocity_msg.linear.x = min(distance_to_goal, 0.3)

        # set the z angular velocity for positive and negative rotations
        if velocity_msg.angular.z > 0:
            velocity_msg.angular.z = min(velocity_msg.angular.z, .3)
        else:
            velocity_msg.angular.z = max(velocity_msg.angular.z, -.3)

        # update the new rotation for the next loop
        last_rotation = rotation
        # publish the new message on /cmd_vel topic
        pub.publish(velocity_msg)
        rate.sleep()

    # Stop the robot
    velocity_msg.linear.x = 0.0
    velocity_msg.angular.z = 0.0
    # publish the new message on /cmd_vel topic
    pub.publish(velocity_msg)

#####A* Algorithm#####

# Storage lists
store_theta = [0]
store_x = [1]
store_y = [1]

# Starting parameters for the A* algorithm
start_x = 1
start_y = 1
start_theta = 0
goal_x = 9
goal_y = 9
RPM1 = 10
RPM2 = 20
clearance = 0.2
clearance = int(clearance * 100)

# Convert coordinates to a string
def CoordToString(x, y):
    if x // 10 < 1:  # lists location as a string with 8 integers (x and y coords) (00000000 to 10001000)
        stringx = '000'
    elif x // 10 < 10:
        stringx = '00'
    elif x // 10 < 100:
        stringx = '0'
    else:
        stringx = ''
    if y // 10 < 1:
        stringy = '000'
    elif y // 10 < 10:
        stringy = '00'
    elif y // 10 < 100:
        stringy = '0'
    else:
        stringy = ''
    return stringx, stringy


obstacles = []
# Create obstacles
for i in range(0, clearance + 1):  # left boundary
    for j in range(0, 1001):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(0, 1001):  # bottom boundary
    for j in range(0, clearance + 1):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(1000 - clearance, 1001):  # right boundary
    for j in range(0, 1001):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(0, 1001):  # top boundary
    for j in range(1000 - clearance, 1001):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(100 - clearance, 300 + clearance):  # obstacle 1: circle
    for j in range(100 - clearance, 300 + clearance):
        if ((i - 200) ** 2 + (j - 200) ** 2 < (100 + clearance) ** 2):
            x = i
            y = j
            stringx, stringy = CoordToString(x, y)
            location = str(stringx + str(int(x)) + stringy + str(int(y)))
            obstacles.append(location)
        else:
            pass

for i in range(100 - clearance, 300 + clearance):  # obstacle 2: circle
    for j in range(700 - clearance, 900 + clearance):
        if ((i - 200) ** 2 + (j - 800) ** 2 < (100 + clearance) ** 2):
            x = i
            y = j
            stringx, stringy = CoordToString(x, y)
            location = str(stringx + str(int(x)) + stringy + str(int(y)))
            obstacles.append(location)
        else:
            pass

for i in range(25 - clearance, 176 + clearance):  # obstacle 3: sqaure
    for j in range(425 - clearance, 576 + clearance):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(375 - clearance, 626 + clearance):  # obstacle 4: rectangle
    for j in range(425 - clearance, 576 + clearance):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

for i in range(725 - clearance, 876 + clearance):  # obstacle 5: rectangle
    for j in range(200 - clearance, 401 + clearance):
        x = i
        y = j
        stringx, stringy = CoordToString(x, y)
        location = str(stringx + str(int(x)) + stringy + str(int(y)))
        obstacles.append(location)

startx, starty = CoordToString(int(start_x * 100), int(start_y * 100))
start_loc = str(startx + str(int(start_x * 100)) + starty + str(int(start_y * 100)))

goalx, goaly = CoordToString(int(goal_x * 100), int(goal_y * 100))
goal_loc = str(goalx + str(int(goal_x * 100)) + goaly + str(int(goal_y * 100)))

# Ensure the starting and ending location are not in objects
if start_loc in obstacles:  # checks that are the inputs are valid
    print("Starting coordinates are either in obstacle or too close to obstacle/boundary. Please try again.")
    sys.exit()

if goal_loc in obstacles:
    print("Goal coordinates are either in obstacle or too close to obstacle/boundary. Please try again.")
    sys.exit()

if start_x > 10 or start_x < 0 or start_y > 10 or start_y < 0:
    print("Starting coordinates are outside boundaries. Please try again.")
    sys.exit()

if goal_x > 10 or goal_x < 0 or goal_y > 10 or goal_y < 0:
    print("Goal coordinates are outside boundaries. Please try again.")
    sys.exit()

actions = [[RPM1, RPM1], [RPM1, 0], [0, RPM1], [RPM1, RPM2], [RPM2, RPM1], [RPM2, RPM2], [0, RPM2], [RPM2, 0]]
path = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

travelled = {}
travelled = {start_loc: [0, 'Q', start_theta, 0]}  # the dictionary of travelled points

# Calculate next x and y locations
def plot_curve(Xi, Yi, Thetai, UL, UR):
    t = 0
    r = 0.038
    L = 0.354
    dt = 0.1
    Xn = Xi
    Yn = Yi
    Thetan = 3.14 * Thetai / 180
    D = 0
    while t < 0.5:
        t = t + dt
        Xs = Xn
        Ys = Yn
        Xn += 0.5 * r * (UL + UR) * math.cos(Thetan) * dt
        Yn += 0.5 * r * (UL + UR) * math.sin(Thetan) * dt
        Thetan += (r / L) * (UR - UL) * dt
        D = math.sqrt(math.pow((0.5 * r * (UL + UR) * math.cos(Thetan) * dt), 2) + math.pow(
            (0.5 * r * (UL + UR) * math.sin(Thetan) * dt), 2))
    Thetan = 180 * (Thetan) / 3.14
    return Xn, Yn, Thetan, D

def checkGoal(x, y):  # function checks if the current node is within the accepted radius of the goal
    if (goal_x - 0.2 <= x <= goal_x + 0.2) and (goal_y - 0.2 <= y <= goal_y + 0.2):
        return True
    else:
        return False

current_x = copy.deepcopy(start_x)
current_y = copy.deepcopy(start_y)
current_cost = travelled[start_loc][0]
current_p = travelled[start_loc][1]
current_theta = travelled[start_loc][2]
current_ctc = travelled[start_loc][3]

# A* algo loop
done = 0
while checkGoal(current_x, current_y) == False:
    i = 0
    done += 1
    for action in actions:
        p = path[i]
        i += 1
        X1 = plot_curve(current_x, current_y, current_theta, action[0], action[1])
        x, y = CoordToString(int(round(X1[0], 2) * 100), int(round(X1[1], 2) * 100))
        loc = str(x + (str(int(round(X1[0], 2) * 100))) + y + (str(int(round(X1[1], 2) * 100))))
        if (loc not in obstacles) and (loc not in travelled) and X1[0] > 0 and X1[0] < 10 and X1[1] > 0 and X1[1] < 10:
            ctg = math.sqrt(((goal_x - X1[0]) ** 2) + ((goal_y - X1[1]) ** 2))
            ctc = current_ctc + X1[3]
            cost = ctc + ctg
            p = current_p + p
            update = {loc: [cost, p, X1[2], ctc]}
            travelled.update(update)

    del travelled[start_loc]
    travelled_copy = copy.deepcopy(travelled)
    travelled_copy = sorted(travelled_copy.items(), key=operator.itemgetter(1))

    start_loc = travelled_copy[0][0]
    current_x = float(start_loc[0:4]) / 100
    current_y = float(start_loc[4:]) / 100
    current_cost = travelled_copy[0][1][0]
    current_p = travelled_copy[0][1][1]
    current_theta = travelled_copy[0][1][2]
    current_ctc = travelled_copy[0][1][3]

    print(current_x, current_y)
    move(current_x, current_y)

print('Goal Reached!')
